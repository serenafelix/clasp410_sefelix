#!/usr/bin/env python3

"""
This is my lab 05 code. It contains functions to solve the snowball Earth
problem using a 1D latitudinal energy balance model with diffusion, spherical
correction, and radiative terms.

It also contains functions to solve and plot the results for questions outlined in the lab assignment.
"""

#imports
import numpy as np
import matplotlib.pyplot as plt

#constants:
radius = 6357000.  #Earth radius in meters.
mxlayer = 50.         #depth of mixed layer (m)
sigma = 5.67e-8      #Steffan-Boltzman constant
heat_cap_h2o = 4.2e6            #heat capacity of water
den_sea = 1020           #density of sea-water (kg/m^3)

def gen_grid(npoints=18):
    '''
    Generate a latitude grid. 

    Parameters:
    npoints : int, defaults to 18
        Number of latitude points to generate.

    Returns:
    dlat : float
        Latitude spacing in degrees.
    lats : Numpy array
        Latitudes in degrees; 0 is south pole, 180 is north.
    '''

    dlat = 180 / npoints  #latitude spacing in degrees.
    lats = np.linspace(dlat/2., 180-dlat/2., npoints) #latitudes at cell centers.

    return dlat, lats


def temp_warm(lats_in):
    '''
    Given latitudes, return a warm Earth initial temperature profile.

    Parameters:
    lats_in : Numpy array
        Latitudes to output temperature. Following the grid standards set in
        the diffusion program, polar angle is defined from the south pole.
        In other words, 0 is the south pole, 180 the north.

    Returns:
    temp : numpy array
        Temperature returned over the input latitudes.
    '''
    #warm Earth temperature profile:
    T_warm = np.array([-47, -19, -11, 1, 9, 14, 19, 23, 25, 25,
                       23, 19, 14, 9, 1, -11, -19, -47])
    

    npoints = T_warm.size #number of points in warm profile
    dlat, lats = gen_grid(npoints) #generate lat grid for warm profile

    coeffs = np.polyfit(lats, T_warm, 2) #fit quadratic to warm profile

    #evaluate quadratic at input latitudes:
    temp = coeffs[2] + coeffs[1]*lats_in + coeffs[0] * lats_in**2

    return temp


def insolation(solar, lats):
    '''
    Calculate the average insolation at each latitude over a year.

    Parameters:
    solar : float
        Solar constant in W/m2.
    lats : Numpy array
        Latitudes in degrees; 0 is south pole, 180 is north.

    Returns:
    insolation : Numpy array   
        Insolation at each latitude in W/m2.
    '''

    max_tilt = 23.5   # tilt of earth in degrees

    insolation = np.zeros(lats.size) #initialize insolation array

    #calculate average solar constant over a day
    dlong = 0.01      #longitude spacing in degrees
    angle = np.cos(np.pi/180. * np.arange(0, 360, dlong)) #solar angle over a day
    angle[angle < 0] = 0 #no negative angles
    total_solar = solar * angle.sum() #total solar over the day
    solar_avg = total_solar / (360/dlong) #average solar over the day

    tilt = [max_tilt * np.cos(2.0*np.pi*day/365) for day in range(365)] #tilt over the year

    #calculate insolation at each latitude
    for i, lat in enumerate(lats):
        zen = lat - 90. + tilt #zenith angle over the year
        zen[zen > 90] = 90
        insolation[i] = solar_avg * np.sum(np.cos(np.pi/180. * zen)) / 365.

    insolation = solar_avg * insolation / 365 #final average over year

    return insolation


def snowball_earth(nlat=18, tfinal=10000, dt=1.0, therm_diff=100., emiss=1.0,
                   init_cond=temp_warm, apply_spherecorr=False, albice=.6,
                   albgnd=.3, apply_insol=False, solar=1370):
    '''
    Solve the snowball Earth problem using a 1D latitudinal energy balance
    model with diffusion, spherical correction, and radiative terms.

    Parameters:
    nlat : int
        Number of latitude points to use.
    tfinal : float
        Final time to run the simulation in years.
    dt : float
        Time step in years.
    therm_diff : float
        Thermal diffusivity in W/m.K.
    emiss : float
        Emissivity of the planet surface.
    init_cond : float or callable
        Initial condition for temperature. If float, sets a constant temperature
        everywhere. If callable, should be a function that takes in latitudes and
        returns temperature at those latitudes.
    apply_spherecorr : bool
        Choose whether or not to apply spherical correction.
    albice : float
        Albedo of ice-covered surface.
    albgnd : float
        Albedo of ice-free surface.
    apply_insol : bool
        Choose whether or not to apply insolation and radiative forcings.
    solar : float
        Solar constant in W/m2.

    Returns:
    lats : Numpy array
        Latitudes in degrees; 0 is south pole, 180 is north.
    Temp : Numpy array
        Temperature at each latitude in degrees Celsius.
    '''

    dlat, lats = gen_grid(nlat) #generate latitude grid
    dy = np.pi * radius / nlat #latitude spacing in meters.

    #create matrix for spherical correction:
    B = np.zeros((nlat, nlat))
    B[np.arange(nlat-1)+1, np.arange(nlat-1)] = -1
    B[np.arange(nlat-1), np.arange(nlat-1)+1] = 1
    B[0, :] = B[-1, :] = 0

    Axz = np.pi * ((radius+50.0)**2 - radius**2) * np.sin(np.pi/180.*lats) #area of each lat band
    dAxz = np.matmul(B, Axz) #change in area between lat bands

    nsteps = int(tfinal / dt) #number of time steps to take.

    dt = dt * 365 * 24 * 3600 #convert dt to seconds

    insol = insolation(solar, lats)

    Temp = np.zeros(nlat) #initialize temperature array.

    #set initial condition:
    if callable(init_cond):
        Temp = init_cond(lats)
    else:
        Temp += init_cond

    #create second matrix for diffusion term
    K = np.zeros((nlat, nlat))
    K[np.arange(nlat), np.arange(nlat)] = -2
    K[np.arange(nlat-1)+1, np.arange(nlat-1)] = 1
    K[np.arange(nlat-1), np.arange(nlat-1)+1] = 1
    K[0, 1], K[-1, -2] = 2, 2 #set boundary condition
    K *= 1/dy**2 #scale

    #matrix for implicit solve of diffusion term
    Linv = np.linalg.inv(np.eye(nlat) - dt * therm_diff * K)

    albedo = np.zeros(nlat) #initialize albedo array
    loc_ice = Temp <= -10 #sea water freezing point
    albedo[loc_ice] = albice #set initial albedo
    albedo[~loc_ice] = albgnd

    #time-step loop
    for istep in range(nsteps):
        #update albedo based on current temperature
        loc_ice = Temp <= -10  #sea water freezing point
        albedo[loc_ice] = albice #set albedo
        albedo[~loc_ice] = albgnd

        #apply spherical correction (maybe)
        if apply_spherecorr:
            sphercorr = (therm_diff*dt) / (4*Axz*dy**2) * np.matmul(B, Temp) * dAxz
        else:
            sphercorr = 0

        #apply radiative/insolation forcings (maybe)
        if apply_insol:
            radiative = (1-albedo)*insol - emiss*sigma*(Temp+273)**4
            Temp += dt * radiative / (den_sea*heat_cap_h2o*mxlayer)

        #solve for diffusion!
        Temp = np.matmul(Linv, Temp + sphercorr)

    return lats, Temp

def q_one():
    '''
    Create solution figure for Problem 1 (also validate our code qualitatively)
    '''

    dlat, lats = gen_grid() #generate latitude grid
    temp_init = temp_warm(lats) #generate initial condition

    lats, temp_diff = snowball_earth() #generate diffusion only solution
    lats, temp_sphe = snowball_earth(apply_spherecorr=True) #generate spherical correction solution
    lats, temp_alls = snowball_earth(apply_spherecorr=True, apply_insol=True, #generate all effects solution
                                     albice=.3)

    #plot results
    fig, ax = plt.subplots(1, 1)
    ax.plot(lats-90, temp_init, label='Initial Condition') #add initial condition
    ax.plot(lats-90, temp_diff, label='Diffusion Only') #add diffusion only
    ax.plot(lats-90, temp_sphe, label='Diffusion + Spherical Corr.') #add spherical correction
    ax.plot(lats-90, temp_alls, label='Diffusion + Spherical Corr. + Radiative') #add all effects
    ax.set_title('Solution after 10,000 Years') #add title
    ax.set_ylabel(r'Temp ($^{\circ}C$)') #add y label
    ax.set_xlabel('Latitude') #add x label
    ax.legend(loc='best') #add legend
    plt.show()


def q_two():
    '''
    Create solution figure for Problem 2
    '''
    varied_diffusivities = [0, 25, 50, 75, 100, 125, 150] #thermal diffusivities to test
    for therm_diff in varied_diffusivities: #loop through diffusivities
        lats, temp_sol = snowball_earth(therm_diff=therm_diff, apply_spherecorr=True,
                                       apply_insol=True, albice=.3)
        plt.plot(lats-90, temp_sol, label=f'Lam={therm_diff} W/m') #plot solution
    plt.title('Solution for Varying Thermal Diffusivities') #add title
    plt.ylabel(r'Temp ($^{\circ}C$)') #add y label
    plt.xlabel('Latitude') #add x label
    plt.legend(loc='best') #add legend
    plt.show()

    varied_emissivities = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] #emissivities to test
    for emiss in varied_emissivities: #loop through emissivities
        lats, temp_sol = snowball_earth(emiss=emiss, apply_spherecorr=True,
                                       apply_insol=True, albice=.3)
        plt.plot(lats-90, temp_sol, label=f'Emiss={emiss:.2f}') #plot solution
    plt.title('Solution for Varying Emissivities') #add title
    plt.ylabel(r'Temp ($^{\circ}C$)') #add y label
    plt.xlabel('Latitude') #add x label
    plt.legend(loc='best') #add legend
    plt.show()

    #check results
    temp_init = temp_warm(lats) #initial condition
    lats, temp_match = snowball_earth(therm_diff=40, emiss=0.73, apply_spherecorr=True, #test the matching condition
                                     apply_insol=True, albice=.3)
    plt.plot(lats-90, temp_init, label='Initial Condition') #plot initial condition
    plt.plot(lats-90, temp_match, label='Matched Condition') #plot matched solution
    plt.title('Matching Initial Conditions') #add title
    plt.ylabel(r'Temp ($^{\circ}C$)') #add y label
    plt.xlabel('Latitude') #add x label
    plt.legend(loc='best') #add legend
    plt.show()

def q_three():
    '''
    Create solution figure for Problem 3
    '''
    #experiment one: hot Earth
    lats, temp_hot = snowball_earth(init_cond=60, therm_diff=40, emiss=0.73, apply_spherecorr=True,
                                   apply_insol=True)
    
    #experiment two: cold Earth
    lats, temp_cold = snowball_earth(init_cond=-60, therm_diff=40, emiss=0.73, apply_spherecorr=True,
                                    apply_insol=True)
    
    #experiment three: flash freeze
    lats, temp_flash = snowball_earth(albice=.6, albgnd=.6, therm_diff=40, emiss=0.73, apply_insol=True,
                                    apply_spherecorr=True)
    
    plt.plot(lats-90, temp_hot, label='Hot Start (60C)') #plot hot start
    plt.plot(lats-90, temp_cold, label='Cold Start (-60C)') #plot cold start
    plt.plot(lats-90, temp_flash, label='Flash Freeze (High Albedo)') #plot flash freeze
    plt.title('Solution for Different Initial Conditions') #add title
    plt.ylabel(r'Temp ($^{\circ}C$)') #add y label
    plt.xlabel('Latitude') #add x label
    plt.legend(loc='best') #add legend
    plt.show()

def q_four():
    '''
    Create solution figure for Problem 4
    '''
    gamma_vals_up = np.arange(0.4, 1.41, 0.05) #solar multipliers
    gamma_vals_down = np.arange(1.4, 0.39, -0.05) #solar multipliers (reverse)
    avgTemps_up = [] #list to hold average temperatures
    gammas_up = [] #list to hold gamma values
    avgTemps_down = [] #list to hold average temperatures
    gammas_down = [] #list to hold gamma values
    temp_init = -60 * np.ones(18)  #initial condition: cold start

    for g in gamma_vals_up: #loop up through gamma values
        sol = g * 1370 #calculate solar constant
        lats, temp_up = snowball_earth(init_cond=temp_init, emiss=0.73, therm_diff=40, apply_spherecorr=True,
                                       apply_insol=True, solar=sol) #solve snowball earth
        avgTemps_up.append(np.mean(temp_up)) #calculate average temperature
        gammas_up.append(g) #store gamma value
        temp_init = temp_up #update initial condition
        
    for g in gamma_vals_down: #loop down through gamma values but everse this time
        sol = g * 1370 #calculate solar constant
        lats, temp_down = snowball_earth(init_cond=temp_init, emiss=0.73, therm_diff=40, apply_spherecorr=True,
                                       apply_insol=True, solar=sol) #solve snowball earth
        avgTemps_down.append(np.mean(temp_down)) #calculate average temperature
        gammas_down.append(g) #store gamma value
        temp_init = temp_down #update initial condition
    
    plt.plot(gammas_up, avgTemps_up, label='Increasing Gamma') #plot increasing gamma
    plt.plot(gammas_down, avgTemps_down, label='Decreasing Gamma') #plot decreasing gamma
    plt.title('Assesing the Stability of the Snowball Earth Model') #add title
    plt.ylabel('Average Temperature (C)') #add y label
    plt.xlabel('Gamma (Solar Multiplier)') #add x label
    plt.legend(loc='best') #add legend
    plt.show()

q_four()